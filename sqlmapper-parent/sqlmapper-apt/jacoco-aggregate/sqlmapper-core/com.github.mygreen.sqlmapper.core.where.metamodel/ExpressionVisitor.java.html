<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ExpressionVisitor.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sqlmapper-apt</a> &gt; <a href="../index.html" class="el_bundle">sqlmapper-core</a> &gt; <a href="index.source.html" class="el_package">com.github.mygreen.sqlmapper.core.where.metamodel</a> &gt; <span class="el_source">ExpressionVisitor.java</span></div><h1>ExpressionVisitor.java</h1><pre class="source lang-java linenums">package com.github.mygreen.sqlmapper.core.where.metamodel;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import org.springframework.util.StringUtils;

import com.github.mygreen.sqlmapper.core.dialect.Dialect;
import com.github.mygreen.sqlmapper.core.meta.EntityMeta;
import com.github.mygreen.sqlmapper.core.meta.PropertyMeta;
import com.github.mygreen.sqlmapper.core.query.FromClause;
import com.github.mygreen.sqlmapper.core.query.IllegalQueryException;
import com.github.mygreen.sqlmapper.core.query.OrderByClause;
import com.github.mygreen.sqlmapper.core.query.SelectClause;
import com.github.mygreen.sqlmapper.core.query.TableNameResolver;
import com.github.mygreen.sqlmapper.core.query.WhereClause;
import com.github.mygreen.sqlmapper.core.util.QueryUtils;
import com.github.mygreen.sqlmapper.metamodel.OrderSpecifier;
import com.github.mygreen.sqlmapper.metamodel.Path;
import com.github.mygreen.sqlmapper.metamodel.PathMeta;
import com.github.mygreen.sqlmapper.metamodel.PathType;
import com.github.mygreen.sqlmapper.metamodel.PropertyPath;
import com.github.mygreen.sqlmapper.metamodel.Visitor;
import com.github.mygreen.sqlmapper.metamodel.expression.Constant;
import com.github.mygreen.sqlmapper.metamodel.expression.SubQueryExpression;
import com.github.mygreen.sqlmapper.metamodel.operation.Operation;
import com.github.mygreen.sqlmapper.metamodel.operation.SubQueryMeta;
import com.github.mygreen.sqlmapper.metamodel.operator.ArithmeticOp;
import com.github.mygreen.sqlmapper.metamodel.operator.BooleanOp;
import com.github.mygreen.sqlmapper.metamodel.operator.ComparisionOp;
import com.github.mygreen.sqlmapper.metamodel.operator.FunctionOp;
import com.github.mygreen.sqlmapper.metamodel.operator.LikeOp;
import com.github.mygreen.sqlmapper.metamodel.operator.Operator;
import com.github.mygreen.sqlmapper.metamodel.operator.UnaryOp;

/**
 * メタモデルの式ノードを巡回するVisitorです。
 *
 *
 * @author T.TSUCHIE
 *
 */
<span class="fc" id="L47">public class ExpressionVisitor implements Visitor&lt;VisitorContext&gt; {</span>

    private Map&lt;Class&lt;?&gt;, OperationHandler&lt;? extends Operator&gt;&gt; operationHandlerMap;
    {
<span class="fc" id="L51">        this.operationHandlerMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L52">        operationHandlerMap.put(BooleanOp.class, new BooleanOpHandler());</span>
<span class="fc" id="L53">        operationHandlerMap.put(UnaryOp.class, new UnaryOpHandler());</span>
<span class="fc" id="L54">        operationHandlerMap.put(ComparisionOp.class, new ComparisionOpHandler());</span>
<span class="fc" id="L55">        operationHandlerMap.put(LikeOp.class, new LikeOpHandler());</span>
<span class="fc" id="L56">        operationHandlerMap.put(FunctionOp.class, new FuncOpHandler());</span>
<span class="fc" id="L57">        operationHandlerMap.put(ArithmeticOp.class, new ArithmeticOpHandler());</span>
<span class="fc" id="L58">    }</span>

    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
    @Override
    public void visit(final Operation&lt;?&gt; expr, final VisitorContext context) {
<span class="fc" id="L63">        final Operator operator = expr.getOperator();</span>

<span class="fc" id="L65">        OperationHandler handler = operationHandlerMap.get(operator.getClass());</span>
<span class="fc" id="L66">        handler.handle(operator, expr, this, context);</span>

<span class="fc" id="L68">    }</span>

    @Override
    public void visit(final Constant&lt;?&gt; expr, final VisitorContext context) {
        // 値はプレースホルダーを追加
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">        if(expr.isExpandable()) {</span>
            // IN句などの展開可能な複数要素の場合
<span class="nc" id="L75">            Collection&lt;?&gt; values = (Collection&lt;?&gt;)expr.getValue();</span>
<span class="nc" id="L76">            context.addParamValues(values);</span>
<span class="nc" id="L77">            context.appendSql(&quot;(&quot;)</span>
<span class="nc" id="L78">                .append(QueryUtils.repeat(&quot;?&quot;, &quot;,&quot;, values.size()))</span>
<span class="nc" id="L79">                .append(&quot;)&quot;);</span>
<span class="nc" id="L80">        } else {</span>
<span class="fc" id="L81">            context.addParamValue(expr.getValue());</span>
<span class="fc" id="L82">            context.appendSql(&quot;?&quot;);</span>

        }

<span class="fc" id="L86">    }</span>


    @Override
    public void visit(final Path&lt;?&gt; expr, final VisitorContext context) {

<span class="fc" id="L92">        final PathMeta pathMeta = expr.getPathMeta();</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">        if(pathMeta.getType() == PathType.PROPERTY) {</span>
<span class="fc" id="L94">            Path&lt;?&gt; rootPath = pathMeta.findRootPath();</span>
<span class="fc" id="L95">            Class&lt;?&gt; rootClassType = rootPath.getType();</span>
<span class="fc" id="L96">            String propertyName = pathMeta.getElement();</span>
<span class="fc" id="L97">            Optional&lt;PropertyMeta&gt; propertyMeta = context.getEntityMetaMap().get(rootClassType).findPropertyMeta(propertyName);</span>
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">            if(propertyMeta.isEmpty()) {</span>
<span class="nc" id="L99">                throw new IllegalQueryException(&quot;unknwon property : &quot; + propertyName);</span>
            }

            // TODO: Embeddedのネストした場合を考慮する
<span class="fc" id="L103">            final String tableName = context.getTableNameResolver().getTableAlias(rootPath);</span>
            final String columnName;
            // SQL - カラム名を追加
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">            if(tableName != null) {</span>
<span class="fc" id="L107">                columnName = tableName + &quot;.&quot; + propertyMeta.get().getColumnMeta().getName();</span>
            } else {
<span class="nc" id="L109">                columnName = propertyMeta.get().getColumnMeta().getName();;</span>
            }
<span class="fc" id="L111">            context.appendSql(columnName);</span>

<span class="fc" id="L113">        } else {</span>
<span class="nc" id="L114">            throw new IllegalArgumentException(&quot;not support pathType=&quot; + pathMeta.getType());</span>
        }

<span class="fc" id="L117">    }</span>

    @Override
    public void visit(final SubQueryExpression&lt;?&gt; expr, final VisitorContext context) {
<span class="fc" id="L121">        final SubQueryMeta queryMeta = expr.getQueryMeta();</span>
<span class="fc" id="L122">        final Dialect dialect = context.getDialect();</span>
<span class="fc" id="L123">        final TableNameResolver tableNameResolver = context.getTableNameResolver();</span>

        // テーブル名の組み立て
        //TODO: テーブル名は新規に割り当てる必要があるかどうか。
<span class="fc" id="L127">        final FromClause fromClause = new FromClause();</span>
<span class="fc" id="L128">        tableNameResolver.prepareTableAlias(queryMeta.getEntityPath());</span>
<span class="fc" id="L129">        EntityMeta entityMeta = context.getEntityMetaFactory().create(queryMeta.getEntityPath().getType());</span>
<span class="fc" id="L130">        fromClause.addSql(entityMeta.getTableMeta().getFullName(), tableNameResolver.getTableAlias(queryMeta.getEntityPath()));</span>

        // 抽出カラムの組み立て
<span class="fc" id="L133">        final SelectClause selectClause = new SelectClause();</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">        for(PropertyMeta propertyMeta : entityMeta.getAllColumnPropertyMeta()) {</span>
<span class="fc" id="L135">            final String propertyName = propertyMeta.getName();</span>
<span class="fc" id="L136">            final PropertyPath&lt;?&gt; propertyPath = queryMeta.getEntityPath().findPropertyPath(propertyName);</span>

<span class="pc bpc" id="L138" title="1 of 2 branches missed.">            if(propertyMeta.isTransient()) {</span>
<span class="nc" id="L139">                continue;</span>
            }

<span class="pc bpc" id="L142" title="1 of 2 branches missed.">            if(!queryMeta.getIncludesProperties().isEmpty()</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">                    &amp;&amp; !queryMeta.getIncludesProperties().contains(propertyPath)) {</span>
<span class="nc" id="L144">                continue;</span>
            }

<span class="fc" id="L147">            String tableAlias = tableNameResolver.getTableAlias(queryMeta.getEntityPath());</span>
<span class="fc" id="L148">            selectClause.addSql(tableAlias, propertyMeta.getColumnMeta().getName());</span>
<span class="fc" id="L149">        }</span>

        // 条件の組み立て
<span class="fc" id="L152">        final WhereClause whereClause = new WhereClause();</span>
<span class="fc" id="L153">        final List&lt;Object&gt; paramValues = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">        if(queryMeta.getWhere() != null) {</span>
<span class="fc" id="L155">            MetamodelWhereVisitor visitor = new MetamodelWhereVisitor(context.getEntityMetaMap(), context.getDialect(),</span>
<span class="fc" id="L156">                    context.getEntityMetaFactory(), tableNameResolver);</span>
<span class="fc" id="L157">            visitor.visit(new MetamodelWhere(queryMeta.getWhere()));</span>

<span class="fc" id="L159">            whereClause.addSql(visitor.getCriteria());</span>
<span class="fc" id="L160">            paramValues.addAll(visitor.getParamValues());</span>
        }

        // 並び順の組み立て
<span class="fc" id="L164">        final OrderByClause orderByClause = new OrderByClause();</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        for(OrderSpecifier order : queryMeta.getOrders()) {</span>
<span class="nc" id="L166">            String propertyName = order.getPath().getPathMeta().getElement();</span>
<span class="nc" id="L167">            Optional&lt;PropertyMeta&gt; propertyMeta = entityMeta.findPropertyMeta(propertyName);</span>

<span class="nc" id="L169">            String tableAlias = tableNameResolver.getTableAlias(order.getPath().getPathMeta().getParent());</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">            if(!StringUtils.hasLength(tableAlias)) {</span>
                //TODO: 例外処理

            }

<span class="nc" id="L175">            propertyMeta.ifPresent(p -&gt; {</span>
<span class="nc" id="L176">                String orderBy = String.format(&quot;%s.%s %s&quot;, tableAlias, p.getColumnMeta().getName(), order.getOrder().name());</span>
<span class="nc" id="L177">                orderByClause.addSql(orderBy);</span>
<span class="nc" id="L178">            });</span>
<span class="nc" id="L179">        }</span>

<span class="fc" id="L181">        String sql = &quot;select &quot;</span>
<span class="fc" id="L182">                + selectClause.toSql()</span>
<span class="fc" id="L183">                + fromClause.toSql()</span>
<span class="fc" id="L184">                + whereClause.toSql()</span>
<span class="fc" id="L185">                + orderByClause.toSql();</span>

        // limit句の組み立て
<span class="pc bpc" id="L188" title="4 of 6 branches missed.">        if(queryMeta.getLimit() &gt; 0 || queryMeta.getLimit() == 0 &amp;&amp; queryMeta.getOffset() &gt; 0) {</span>
<span class="nc" id="L189">            sql = dialect.convertLimitSql(sql, queryMeta.getOffset(), queryMeta.getLimit());</span>
        }

        // 組み立てたSQLとパラメータを格納する
<span class="fc" id="L193">        context.addParamValues(paramValues);</span>
<span class="fc" id="L194">        context.appendSql(sql);</span>
<span class="fc" id="L195">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>