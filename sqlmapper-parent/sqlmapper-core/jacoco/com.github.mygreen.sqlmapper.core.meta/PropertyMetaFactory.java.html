<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PropertyMetaFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sqlmapper-core</a> &gt; <a href="index.source.html" class="el_package">com.github.mygreen.sqlmapper.core.meta</a> &gt; <span class="el_source">PropertyMetaFactory.java</span></div><h1>PropertyMetaFactory.java</h1><pre class="source lang-java linenums">package com.github.mygreen.sqlmapper.core.meta;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.text.DecimalFormat;
import java.util.Optional;
import java.util.UUID;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.util.ReflectionUtils;

import com.github.mygreen.messageformatter.MessageFormatter;
import com.github.mygreen.sqlmapper.core.annotation.Column;
import com.github.mygreen.sqlmapper.core.annotation.Enumerated;
import com.github.mygreen.sqlmapper.core.annotation.GeneratedValue;
import com.github.mygreen.sqlmapper.core.annotation.GeneratedValue.GenerationType;
import com.github.mygreen.sqlmapper.core.annotation.Id;
import com.github.mygreen.sqlmapper.core.annotation.SequenceGenerator;
import com.github.mygreen.sqlmapper.core.annotation.TableGenerator;
import com.github.mygreen.sqlmapper.core.annotation.Temporal;
import com.github.mygreen.sqlmapper.core.annotation.Version;
import com.github.mygreen.sqlmapper.core.config.TableIdGeneratorProperties;
import com.github.mygreen.sqlmapper.core.dialect.Dialect;
import com.github.mygreen.sqlmapper.core.id.IdGenerator;
import com.github.mygreen.sqlmapper.core.id.IdentityIdGenerator;
import com.github.mygreen.sqlmapper.core.id.SequenceIdGenerator;
import com.github.mygreen.sqlmapper.core.id.TableIdContext;
import com.github.mygreen.sqlmapper.core.id.TableIdGenerator;
import com.github.mygreen.sqlmapper.core.id.TableIdIncrementer;
import com.github.mygreen.sqlmapper.core.id.UUIDGenerator;
import com.github.mygreen.sqlmapper.core.naming.NamingRule;
import com.github.mygreen.sqlmapper.core.type.ValueType;
import com.github.mygreen.sqlmapper.core.type.ValueTypeRegistry;
import com.github.mygreen.sqlmapper.core.util.ClassUtils;
import com.github.mygreen.sqlmapper.core.util.NameUtils;

import lombok.Getter;
import lombok.Setter;

/**
 * プロパティのメタ情報を作成します。
 *
 *
 * @author T.TSUCHIE
 *
 */
<span class="fc" id="L52">public class PropertyMetaFactory {</span>

<span class="nc" id="L54">    @Getter</span>
<span class="nc" id="L55">    @Setter</span>
    @Autowired
    private NamingRule namingRule;

<span class="nc" id="L59">    @Getter</span>
<span class="nc" id="L60">    @Setter</span>
    @Autowired
    private MessageFormatter messageFormatter;

<span class="nc" id="L64">    @Getter</span>
<span class="nc" id="L65">    @Setter</span>
    @Autowired
    private ValueTypeRegistry valueTypeRegistry;

<span class="nc" id="L69">    @Getter</span>
<span class="nc" id="L70">    @Setter</span>
    @Autowired
    private Dialect dialect;

<span class="nc" id="L74">    @Getter</span>
<span class="nc" id="L75">    @Setter</span>
    @Autowired
    private DataSource dataSource;

<span class="nc" id="L79">    @Getter</span>
<span class="nc" id="L80">    @Setter</span>
    @Autowired
    private JdbcTemplate jdbcTemplate;

<span class="nc" id="L84">    @Getter</span>
<span class="nc" id="L85">    @Setter</span>
    @Autowired
    private TableIdGeneratorProperties tableIdGeneratorProperties;

    /**
     * プロパティのメタ情報を作成します。
     * @param field フィールド
     * @param entityMeta エンティティのメタ情報
     * @return プロパティのメタ情報
     */
    public PropertyMeta create(final Field field, final EntityMeta entityMeta) {

<span class="fc" id="L97">        final Class&lt;?&gt; declaringClass = field.getDeclaringClass();</span>
<span class="fc" id="L98">        final PropertyMeta propertyMeta = new PropertyMeta(field.getName(), field.getType());</span>
<span class="fc" id="L99">        doField(propertyMeta, field);</span>

        // フィールドに対するgetter/setterメソッドを設定します。
<span class="fc bfc" id="L102" title="All 2 branches covered.">        for(Method method : declaringClass.getMethods()) {</span>
<span class="fc" id="L103">            ReflectionUtils.makeAccessible(method);</span>

<span class="fc" id="L105">            int modifiers = method.getModifiers();</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">            if(Modifier.isStatic(modifiers)) {</span>
<span class="nc" id="L107">                continue;</span>
            }

<span class="fc bfc" id="L110" title="All 2 branches covered.">            if(ClassUtils.isSetterMethod(method)) {</span>
<span class="fc" id="L111">                doSetterMethod(propertyMeta, method);</span>

<span class="fc bfc" id="L113" title="All 4 branches covered.">            } else if(ClassUtils.isGetterMethod(method) || ClassUtils.isBooleanGetterMethod(method)) {</span>
<span class="fc" id="L114">                doGetterMethod(propertyMeta, method);</span>
            }
        }

        // 永続化対象のプロパティはカラム情報を設定します。
<span class="fc bfc" id="L119" title="All 4 branches covered.">        if(!propertyMeta.isEmbedded() &amp;&amp; !propertyMeta.isTransient()) {</span>

<span class="fc" id="L121">            doColumnMeta(propertyMeta);</span>
<span class="fc" id="L122">            doIdGenerator(propertyMeta, entityMeta);</span>

            // プロパティに対する型変換を設定します。
<span class="fc" id="L125">            ValueType&lt;?&gt; valueType = valueTypeRegistry.findValueType(propertyMeta);</span>

            // OracleなどBoolean型を純粋にサポートしていない場合は、int型に変換するタイプに変換する。
<span class="fc" id="L128">            valueType = dialect.getValueType(valueType);</span>
<span class="fc" id="L129">            propertyMeta.setValueType(valueType);</span>


<span class="fc" id="L132">            validateColumnProperty(declaringClass, propertyMeta);</span>

        }

<span class="fc" id="L136">        return propertyMeta;</span>

    }

    /**
     * プロパティのメタ情報に対する処理を実行します。
     * @param propertyMeta プロパティのメタ情報
     * @param field フィールド情報
     */
    private void doField(final PropertyMeta propertyMeta, final Field field) {

<span class="fc" id="L147">        propertyMeta.setField(field);</span>

<span class="fc" id="L149">        final Annotation[] annos = field.getAnnotations();</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">        for(Annotation anno : annos) {</span>
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">            if(!isSupportedAnnotation(anno)) {</span>
<span class="nc" id="L152">                continue;</span>
            }

<span class="fc" id="L155">            final Class&lt;? extends Annotation&gt; annoClass = anno.annotationType();</span>
<span class="fc" id="L156">            propertyMeta.addAnnotation(annoClass, anno);</span>
        }
<span class="fc" id="L158">    }</span>

    /**
     * サポートするアノテーションか判定する。
     * &lt;p&gt;確実に重複するJava標準のアノテーションは除外するようにします。&lt;/p&gt;
     *
     * @param anno 判定対象のアノテーション
     * @return tureのときサポートします。
     */
    private boolean isSupportedAnnotation(final Annotation anno) {

<span class="fc" id="L169">        final String name = anno.annotationType().getName();</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if(name.startsWith(&quot;java.lang.annotation.&quot;)) {</span>
<span class="nc" id="L171">            return false;</span>
        }

<span class="fc" id="L174">        return true;</span>
    }

    /**
     * setterメソッドの情報を処理する。
     * @param propertyMeta プロパティのメタ情報
     * @param method setterメソッド
     */
    private void doSetterMethod(final PropertyMeta propertyMeta, final Method method) {

<span class="fc" id="L184">        final String methodName = method.getName();</span>
<span class="fc" id="L185">        final String propertyName = NameUtils.uncapitalize(methodName.substring(3));</span>

<span class="fc bfc" id="L187" title="All 2 branches covered.">        if(!propertyMeta.getName().equals(propertyName)) {</span>
            // プロパティ名が一致しない場合はスキップする
<span class="fc" id="L189">            return;</span>
        }

<span class="fc" id="L192">        propertyMeta.setWriteMethod(method);</span>

<span class="fc" id="L194">    }</span>

    /**
     * getterメソッドの情報を処理する。
     * @param propertyMeta プロパティのメタ情報
     * @param method getterメソッド
     */
    private void doGetterMethod(final PropertyMeta propertyMeta, final Method method) {

<span class="fc" id="L203">        final String methodName = method.getName();</span>
        final String propertyName;
<span class="fc bfc" id="L205" title="All 2 branches covered.">        if(methodName.startsWith(&quot;get&quot;)) {</span>
<span class="fc" id="L206">            propertyName = NameUtils.uncapitalize(methodName.substring(3));</span>
        } else {
            // 「is」から始まる場合
<span class="fc" id="L209">            propertyName = NameUtils.uncapitalize(methodName.substring(2));</span>
        }

<span class="fc bfc" id="L212" title="All 2 branches covered.">        if(!propertyMeta.getName().equals(propertyName)) {</span>
            // プロパティ名が一致しない場合はスキップする
<span class="fc" id="L214">            return;</span>
        }

<span class="fc" id="L217">        propertyMeta.setReadMethod(method);</span>

<span class="fc" id="L219">    }</span>

    /**
     * カラム情報を処理する。
     * @param propertyMeta プロパティのメタ情報
     */
    private void doColumnMeta(final PropertyMeta propertyMeta) {

<span class="fc" id="L227">        final ColumnMeta columnMeta = new ColumnMeta();</span>

<span class="fc" id="L229">        final String defaultColumnName = namingRule.propertyToColumn(propertyMeta.getName());</span>

<span class="fc" id="L231">        Optional&lt;Column&gt; annoColumn = propertyMeta.getAnnotation(Column.class);</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">        if(annoColumn.isPresent()) {</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">            if(!annoColumn.get().name().isEmpty()) {</span>
<span class="fc" id="L234">                columnMeta.setName(annoColumn.get().name());</span>
            } else {
<span class="nc" id="L236">                columnMeta.setName(defaultColumnName);</span>
            }

<span class="fc" id="L239">            columnMeta.setInsertable(annoColumn.get().insertable());</span>
<span class="fc" id="L240">            columnMeta.setUpdatable(annoColumn.get().insertable());</span>

        } else {
<span class="fc" id="L243">            columnMeta.setName(defaultColumnName);</span>
        }

<span class="fc" id="L246">        propertyMeta.setColumnMeta(columnMeta);</span>

<span class="fc" id="L248">    }</span>

    /**
     * 主キーの生成情報を処理します。
     * @param propertyMeta プロパティのメタ情報
     * @param entityMeta エンティティのメタ情報
     */
    private void doIdGenerator(final PropertyMeta propertyMeta, final EntityMeta entityMeta) {

<span class="fc bfc" id="L257" title="All 2 branches covered.">        if(!propertyMeta.isId()) {</span>
<span class="fc" id="L258">            return;</span>
        }

<span class="fc" id="L261">        Optional&lt;GeneratedValue&gt; annoGeneratedValue = propertyMeta.getAnnotation(GeneratedValue.class);</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">        if(annoGeneratedValue.isEmpty()) {</span>
<span class="fc" id="L263">            return;</span>
        }

<span class="fc" id="L266">        final Class&lt;?&gt; propertyType = propertyMeta.getPropertyType();</span>

<span class="fc" id="L268">        GenerationType generationType = annoGeneratedValue.get().strategy();</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        if(generationType == GenerationType.AUTO) {</span>
<span class="nc" id="L270">            generationType = dialect.getDefaultGenerationType();</span>
        }

        final IdGenerator idGenerator;
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">        if(generationType == GenerationType.IDENTITY) {</span>
<span class="fc" id="L275">            IdentityIdGenerator identityIdGenerator = new IdentityIdGenerator(propertyType);</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">            if(!annoGeneratedValue.get().format().isEmpty()) {</span>
<span class="nc" id="L277">                identityIdGenerator.setFormatter(new DecimalFormat(annoGeneratedValue.get().format()));</span>
            }
<span class="fc" id="L279">            idGenerator = identityIdGenerator;</span>

<span class="pc bnc" id="L281" title="All 2 branches missed.">        } else if(generationType == GenerationType.SEQUENCE) {</span>
<span class="nc" id="L282">            Optional&lt;SequenceGenerator&gt; annoSequenceGenerator = propertyMeta.getAnnotation(SequenceGenerator.class);</span>
            final String sequenceName;
<span class="nc bnc" id="L284" title="All 2 branches missed.">            if(annoSequenceGenerator.isPresent()) {</span>
<span class="nc" id="L285">                sequenceName = NameUtils.tableFullName(annoSequenceGenerator.get().sequenceName(),</span>
<span class="nc" id="L286">                        annoSequenceGenerator.get().catalog(),</span>
<span class="nc" id="L287">                        annoSequenceGenerator.get().schema());</span>
            } else {
<span class="nc" id="L289">                sequenceName = entityMeta.getTableMeta().getName() + &quot;_&quot; + propertyMeta.getColumnMeta().getName();</span>
            }
<span class="nc" id="L291">            SequenceIdGenerator sequenceIdGenerator = new SequenceIdGenerator(</span>
<span class="nc" id="L292">                    dialect.getSequenceIncrementer(dataSource, sequenceName), propertyType);</span>

<span class="nc bnc" id="L294" title="All 2 branches missed.">            if(!annoGeneratedValue.get().format().isEmpty()) {</span>
<span class="nc" id="L295">                sequenceIdGenerator.setFormatter(new DecimalFormat(annoGeneratedValue.get().format()));</span>
            }

<span class="nc" id="L298">            idGenerator = sequenceIdGenerator;</span>

<span class="nc bnc" id="L300" title="All 2 branches missed.">        } else if(generationType == GenerationType.TABLE) {</span>
<span class="nc" id="L301">            Optional&lt;TableGenerator&gt; annoTableGenerator = propertyMeta.getAnnotation(TableGenerator.class);</span>

<span class="nc" id="L303">            final TableIdContext tableIdContext = new TableIdContext();</span>
<span class="nc" id="L304">            tableIdContext.setTable(tableIdGeneratorProperties.getTable());</span>
<span class="nc" id="L305">            tableIdContext.setSchema(tableIdGeneratorProperties.getSchema());</span>
<span class="nc" id="L306">            tableIdContext.setCatalog(tableIdGeneratorProperties.getCatalog());</span>
<span class="nc" id="L307">            tableIdContext.setPkColumn(tableIdGeneratorProperties.getPkColumn());</span>
<span class="nc" id="L308">            tableIdContext.setValueColumn(tableIdGeneratorProperties.getValueColumn());</span>
<span class="nc" id="L309">            tableIdContext.setAllocationSize(tableIdGeneratorProperties.getAllocationSize());</span>
<span class="nc" id="L310">            tableIdContext.setInitialValue(tableIdGeneratorProperties.getInitialValue());</span>

<span class="nc" id="L312">            String sequenceName = entityMeta.getTableMeta().getName() + &quot;_&quot; + propertyMeta.getColumnMeta().getName();</span>

<span class="nc" id="L314">            annoTableGenerator.ifPresent(a -&gt; {</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">                if(!a.table().isEmpty()) {</span>
<span class="nc" id="L316">                    tableIdContext.setTable(a.table());</span>
                }

<span class="nc bnc" id="L319" title="All 2 branches missed.">                if(!a.schema().isEmpty()) {</span>
<span class="nc" id="L320">                    tableIdContext.setSchema(a.schema());</span>
                }

<span class="nc bnc" id="L323" title="All 2 branches missed.">                if(!a.catalog().isEmpty()) {</span>
<span class="nc" id="L324">                    tableIdContext.setCatalog(a.catalog());</span>
                }

<span class="nc bnc" id="L327" title="All 2 branches missed.">                if(!a.pkColumn().isEmpty()) {</span>
<span class="nc" id="L328">                    tableIdContext.setPkColumn(a.pkColumn());</span>
                }

<span class="nc bnc" id="L331" title="All 2 branches missed.">                if(!a.valueColumn().isEmpty()) {</span>
<span class="nc" id="L332">                    tableIdContext.setValueColumn(a.valueColumn());</span>
                }

<span class="nc bnc" id="L335" title="All 2 branches missed.">                if(a.initialValue() &gt;= 0L) {</span>
<span class="nc" id="L336">                    tableIdContext.setInitialValue(a.initialValue());</span>
                } else {
<span class="nc" id="L338">                    throw new InvalidEntityException(entityMeta.getEntityType(), messageFormatter.create(&quot;property.anno.attr.min&quot;)</span>
<span class="nc" id="L339">                            .paramWithClass(&quot;classType&quot;, entityMeta.getEntityType())</span>
<span class="nc" id="L340">                            .param(&quot;property&quot;, propertyMeta.getName())</span>
<span class="nc" id="L341">                            .paramWithAnno(&quot;anno&quot;, TableGenerator.class)</span>
<span class="nc" id="L342">                            .param(&quot;attrName&quot;, &quot;initialValue&quot;)</span>
<span class="nc" id="L343">                            .param(&quot;attrValue&quot;, a.initialValue())</span>
<span class="nc" id="L344">                            .param(&quot;min&quot;, 0)</span>
<span class="nc" id="L345">                            .format());</span>
                }

<span class="nc bnc" id="L348" title="All 2 branches missed.">                if(a.allocationSize() &gt;= 1L) {</span>
<span class="nc" id="L349">                    tableIdContext.setAllocationSize(a.allocationSize());</span>
                } else {
<span class="nc" id="L351">                    throw new InvalidEntityException(entityMeta.getEntityType(), messageFormatter.create(&quot;property.anno.attr.min&quot;)</span>
<span class="nc" id="L352">                            .paramWithClass(&quot;classType&quot;, entityMeta.getEntityType())</span>
<span class="nc" id="L353">                            .param(&quot;property&quot;, propertyMeta.getName())</span>
<span class="nc" id="L354">                            .paramWithAnno(&quot;anno&quot;, TableGenerator.class)</span>
<span class="nc" id="L355">                            .param(&quot;attrName&quot;, &quot;allocationSize&quot;)</span>
<span class="nc" id="L356">                            .param(&quot;attrValue&quot;, a.allocationSize())</span>
<span class="nc" id="L357">                            .param(&quot;min&quot;, 1)</span>
<span class="nc" id="L358">                            .format());</span>
                }

<span class="nc" id="L361">            });</span>


<span class="nc bnc" id="L364" title="All 4 branches missed.">            if(annoTableGenerator.isPresent() &amp;&amp; annoTableGenerator.get().pkColumn().isEmpty()) {</span>
<span class="nc" id="L365">                sequenceName = annoTableGenerator.get().pkColumn();</span>
            }

<span class="nc" id="L368">            TableIdGenerator tableIdGenerator = new TableIdGenerator(</span>
                    new TableIdIncrementer(jdbcTemplate, tableIdContext),
<span class="nc" id="L370">                    propertyMeta.getPropertyType(), sequenceName);</span>


<span class="nc bnc" id="L373" title="All 2 branches missed.">            if(!annoGeneratedValue.get().format().isEmpty()) {</span>
                try {
<span class="nc" id="L375">                    tableIdGenerator.setFormatter(new DecimalFormat(annoGeneratedValue.get().format()));</span>
<span class="nc" id="L376">                } catch(IllegalArgumentException e) {</span>
<span class="nc" id="L377">                    throw new InvalidEntityException(entityMeta.getEntityType(), messageFormatter.create(&quot;property.anno.attr.wrongFormat&quot;)</span>
<span class="nc" id="L378">                            .paramWithClass(&quot;classType&quot;, entityMeta.getEntityType())</span>
<span class="nc" id="L379">                            .param(&quot;property&quot;, propertyMeta.getName())</span>
<span class="nc" id="L380">                            .paramWithAnno(&quot;anno&quot;, TableGenerator.class)</span>
<span class="nc" id="L381">                            .param(&quot;attrName&quot;, &quot;format&quot;)</span>
<span class="nc" id="L382">                            .param(&quot;attrValue&quot;, annoGeneratedValue.get().format())</span>
<span class="nc" id="L383">                            .format(), e);</span>
<span class="nc" id="L384">                }</span>
            }

<span class="nc" id="L387">            idGenerator = tableIdGenerator;</span>


<span class="nc bnc" id="L390" title="All 2 branches missed.">        } else if(generationType == GenerationType.UUID) {</span>
<span class="nc" id="L391">            idGenerator = new UUIDGenerator(propertyType);</span>

        } else {
<span class="nc" id="L394">            throw new InvalidEntityException(entityMeta.getEntityType(), messageFormatter.create(&quot;property.anno.attr.notSupportValue&quot;)</span>
<span class="nc" id="L395">                    .paramWithClass(&quot;classType&quot;, entityMeta.getClass())</span>
<span class="nc" id="L396">                    .param(&quot;property&quot;, propertyMeta.getName())</span>
<span class="nc" id="L397">                    .paramWithAnno(&quot;anno&quot;, GeneratedValue.class)</span>
<span class="nc" id="L398">                    .param(&quot;attrName&quot;, &quot;strategy&quot;)</span>
<span class="nc" id="L399">                    .paramWithEnum(&quot;attrValue&quot;, generationType)</span>
<span class="nc" id="L400">                    .format());</span>
        }

<span class="pc bpc" id="L403" title="1 of 2 branches missed.">        if(!idGenerator.isSupportedType(propertyType)) {</span>
<span class="nc" id="L404">            throw new InvalidEntityException(entityMeta.getClass(), messageFormatter.create(&quot;property.anno.notSupportTypeList&quot;)</span>
<span class="nc" id="L405">                    .paramWithClass(&quot;classType&quot;, entityMeta.getEntityType())</span>
<span class="nc" id="L406">                    .param(&quot;property&quot;, propertyMeta.getName())</span>
<span class="nc" id="L407">                    .paramWithAnno(&quot;anno&quot;, GeneratedValue.class)</span>
<span class="nc" id="L408">                    .paramWithClass(&quot;actualType&quot;, propertyType)</span>
<span class="nc" id="L409">                    .paramWithClass(&quot;expectedTypeList&quot;, idGenerator.getSupportedTypes())</span>
<span class="nc" id="L410">                    .format());</span>
        }

<span class="fc" id="L413">        propertyMeta.setIdGenerator(idGenerator);</span>
<span class="fc" id="L414">        propertyMeta.setIdGeneratonType(generationType);</span>
        //TODO: SpringからBeanを取得するする

<span class="fc" id="L417">    }</span>

    /**
     * カラムとなるプロパティの整合性のチェック。
     * アノテーションとクラスタイプのチェック
     *
     * @param declaringClass プロパティが定義されているクラス
     * @param propertyMeta チェック対象のプロパティ
     */
    private void validateColumnProperty(final Class&lt;?&gt; declaringClass, final PropertyMeta propertyMeta) {

<span class="fc" id="L428">        final Class&lt;?&gt; propertyType = propertyMeta.getPropertyType();</span>

        // 主キーのタイプチェック
<span class="pc bpc" id="L431" title="3 of 14 branches missed.">        if(propertyMeta.isId()</span>
                &amp;&amp; propertyType != String.class
                &amp;&amp; propertyType != UUID.class
                &amp;&amp; propertyType != Integer.class &amp;&amp; propertyType != int.class
                &amp;&amp; propertyType != Long.class &amp;&amp; propertyType != long.class) {

<span class="nc" id="L437">            throw new InvalidEntityException(declaringClass, messageFormatter.create(&quot;property.anno.notSupportTypeList&quot;)</span>
<span class="nc" id="L438">                    .paramWithClass(&quot;entityType&quot;, declaringClass)</span>
<span class="nc" id="L439">                    .param(&quot;propperty&quot;, propertyMeta.getName())</span>
<span class="nc" id="L440">                    .paramWithAnno(&quot;anno&quot;, Id.class)</span>
<span class="nc" id="L441">                    .paramWithClass(&quot;actualType&quot;, propertyType)</span>
<span class="nc" id="L442">                    .paramWithClass(&quot;expectedTypeList&quot;, String.class, Integer.class, int.class, Long.class, long.class)</span>
<span class="nc" id="L443">                    .format());</span>
        }

        // 主キーでないのに値の生成用のアノテーションが付与されている場合
<span class="pc bpc" id="L447" title="1 of 4 branches missed.">        if(!propertyMeta.isId() &amp;&amp; propertyMeta.hasAnnotation(GeneratedValue.class)) {</span>

<span class="nc" id="L449">            throw new InvalidEntityException(declaringClass, messageFormatter.create(&quot;property.anno.notIdWithGeneratedValue&quot;)</span>
<span class="nc" id="L450">                    .paramWithClass(&quot;entityType&quot;, declaringClass)</span>
<span class="nc" id="L451">                    .param(&quot;propperty&quot;, propertyMeta.getName())</span>
<span class="nc" id="L452">                    .paramWithAnno(&quot;anno&quot;, GeneratedValue.class)</span>
<span class="nc" id="L453">                    .format());</span>
        }


        // 列挙型のタイプチェック
<span class="pc bpc" id="L458" title="1 of 4 branches missed.">        if(propertyMeta.hasAnnotation(Enumerated.class) &amp;&amp; !propertyType.isEnum()) {</span>

<span class="nc" id="L460">            throw new InvalidEntityException(declaringClass, messageFormatter.create(&quot;property.anno.notSupportType&quot;)</span>
<span class="nc" id="L461">                    .paramWithClass(&quot;entityType&quot;, declaringClass)</span>
<span class="nc" id="L462">                    .param(&quot;propperty&quot;, propertyMeta.getName())</span>
<span class="nc" id="L463">                    .paramWithAnno(&quot;anno&quot;, Enumerated.class)</span>
<span class="nc" id="L464">                    .paramWithClass(&quot;actualType&quot;, propertyType)</span>
<span class="nc" id="L465">                    .paramWithClass(&quot;expectedType&quot;, Enum.class)</span>
<span class="nc" id="L466">                    .format());</span>
        }

        // バージョンキーのタイプチェック
<span class="pc bpc" id="L470" title="4 of 10 branches missed.">        if(propertyMeta.hasAnnotation(Version.class)</span>
                &amp;&amp; propertyType != Integer.class &amp;&amp; propertyType != int.class
                &amp;&amp; propertyType != Long.class &amp;&amp; propertyType != long.class) {

<span class="nc" id="L474">            throw new InvalidEntityException(declaringClass, messageFormatter.create(&quot;property.anno.notSupportTypeList&quot;)</span>
<span class="nc" id="L475">                    .paramWithClass(&quot;entityType&quot;, declaringClass)</span>
<span class="nc" id="L476">                    .param(&quot;propperty&quot;, propertyMeta.getName())</span>
<span class="nc" id="L477">                    .paramWithAnno(&quot;anno&quot;, Version.class)</span>
<span class="nc" id="L478">                    .paramWithClass(&quot;actualType&quot;, propertyType)</span>
<span class="nc" id="L479">                    .paramWithClass(&quot;expectedTypeList&quot;, Integer.class, int.class, Long.class, long.class)</span>
<span class="nc" id="L480">                    .format());</span>

        }

        // 時制のタイプチェック
<span class="pc bpc" id="L485" title="1 of 4 branches missed.">        if(!propertyMeta.hasAnnotation(Temporal.class)</span>
                &amp;&amp; propertyType == java.util.Date.class) {

            // 時制の型が不明なプロパティに対して、@Temporalが付与されていない場合
<span class="nc" id="L489">            throw new InvalidEntityException(declaringClass, messageFormatter.create(&quot;property.anno.requiredAnnoTemporal&quot;)</span>
<span class="nc" id="L490">                    .paramWithClass(&quot;entityType&quot;, declaringClass)</span>
<span class="nc" id="L491">                    .param(&quot;propperty&quot;, propertyMeta.getName())</span>
<span class="nc" id="L492">                    .paramWithAnno(&quot;anno&quot;, Temporal.class)</span>
<span class="nc" id="L493">                    .format());</span>
        }

<span class="fc" id="L496">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>