<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>PropertyMetaFactory.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">SqlMapper</a> &gt; <a href="../index.html" class="el_bundle">sqlmapper-core</a> &gt; <a href="index.source.html" class="el_package">com.github.mygreen.sqlmapper.core.meta</a> &gt; <span class="el_source">PropertyMetaFactory.java</span></div><h1>PropertyMetaFactory.java</h1><pre class="source lang-java linenums">package com.github.mygreen.sqlmapper.core.meta;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.text.DecimalFormat;
import java.util.Optional;
import java.util.UUID;

import javax.sql.DataSource;

import org.springframework.beans.factory.BeanNotOfRequiredTypeException;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.util.ReflectionUtils;
import org.springframework.util.StringUtils;

import com.github.mygreen.messageformatter.MessageFormatter;
import com.github.mygreen.sqlmapper.core.annotation.Column;
import com.github.mygreen.sqlmapper.core.annotation.Enumerated;
import com.github.mygreen.sqlmapper.core.annotation.GeneratedValue;
import com.github.mygreen.sqlmapper.core.annotation.GeneratedValue.GenerationType;
import com.github.mygreen.sqlmapper.core.annotation.Id;
import com.github.mygreen.sqlmapper.core.annotation.SequenceGenerator;
import com.github.mygreen.sqlmapper.core.annotation.TableGenerator;
import com.github.mygreen.sqlmapper.core.annotation.Temporal;
import com.github.mygreen.sqlmapper.core.annotation.Version;
import com.github.mygreen.sqlmapper.core.config.JdbcTemplateProperties;
import com.github.mygreen.sqlmapper.core.config.TableIdGeneratorProperties;
import com.github.mygreen.sqlmapper.core.dialect.Dialect;
import com.github.mygreen.sqlmapper.core.id.IdGenerationContext;
import com.github.mygreen.sqlmapper.core.id.IdGenerator;
import com.github.mygreen.sqlmapper.core.id.IdentityIdGenerator;
import com.github.mygreen.sqlmapper.core.id.SequenceIdGenerator;
import com.github.mygreen.sqlmapper.core.id.TableIdContext;
import com.github.mygreen.sqlmapper.core.id.TableIdGenerator;
import com.github.mygreen.sqlmapper.core.id.TableIdIncrementer;
import com.github.mygreen.sqlmapper.core.id.UUIDGenerator;
import com.github.mygreen.sqlmapper.core.naming.NamingRule;
import com.github.mygreen.sqlmapper.core.query.JdbcTemplateBuilder;
import com.github.mygreen.sqlmapper.core.type.ValueType;
import com.github.mygreen.sqlmapper.core.type.ValueTypeRegistry;
import com.github.mygreen.sqlmapper.core.util.ClassUtils;
import com.github.mygreen.sqlmapper.core.util.NameUtils;

import lombok.Getter;
import lombok.Setter;

/**
 * プロパティのメタ情報を作成します。
 *
 * @version 0.3
 * @author T.TSUCHIE
 *
 */
<span class="fc" id="L59">public class PropertyMetaFactory {</span>

    @Getter
    @Setter
    @Autowired
    private NamingRule namingRule;

    @Getter
    @Setter
    @Autowired
    private MessageFormatter messageFormatter;

    @Getter
    @Setter
    @Autowired
    private ValueTypeRegistry valueTypeRegistry;

    @Getter
    @Setter
    @Autowired
    private Dialect dialect;

    @Getter
    @Setter
    @Autowired
    private DataSource dataSource;

    @Getter
    @Setter
    @Autowired
    private JdbcTemplateProperties jdbcTemplateProperties;

    @Getter
    @Setter
    @Autowired
    private TableIdGeneratorProperties tableIdGeneratorProperties;

    @Getter
    @Setter
    @Autowired
    private ApplicationContext applicationContext;

    /**
     * プロパティのメタ情報を作成します。
     * @param field フィールド
     * @param entityMeta エンティティのメタ情報。空の場合はID情報の処理をスキップします。
     * @param embeddedId 埋め込み型のIDのプロパティかどうか。
     * @return プロパティのメタ情報
     */
    public PropertyMeta create(final Field field, final Optional&lt;EntityMeta&gt; entityMeta, final boolean embeddedId) {

<span class="fc" id="L110">        final Class&lt;?&gt; declaringClass = field.getDeclaringClass();</span>
<span class="fc" id="L111">        final PropertyMeta propertyMeta = new PropertyMeta(field.getName(), field.getType());</span>
<span class="fc" id="L112">        propertyMeta.setEmbeddedableId(embeddedId);</span>
<span class="fc" id="L113">        doField(propertyMeta, field);</span>

        // フィールドに対するgetter/setterメソッドを設定します。
<span class="fc bfc" id="L116" title="All 2 branches covered.">        for(Method method : declaringClass.getMethods()) {</span>
<span class="fc" id="L117">            ReflectionUtils.makeAccessible(method);</span>

<span class="fc" id="L119">            int modifiers = method.getModifiers();</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">            if(Modifier.isStatic(modifiers)) {</span>
<span class="nc" id="L121">                continue;</span>
            }

<span class="fc bfc" id="L124" title="All 2 branches covered.">            if(ClassUtils.isSetterMethod(method)) {</span>
<span class="fc" id="L125">                doSetterMethod(propertyMeta, method);</span>

<span class="fc bfc" id="L127" title="All 4 branches covered.">            } else if(ClassUtils.isGetterMethod(method) || ClassUtils.isBooleanGetterMethod(method)) {</span>
<span class="fc" id="L128">                doGetterMethod(propertyMeta, method);</span>
            }
        }

        // 永続化対象のプロパティはカラム情報を設定します。
<span class="fc bfc" id="L133" title="All 4 branches covered.">        if(!propertyMeta.isEmbedded() &amp;&amp; !propertyMeta.isTransient()) {</span>

<span class="fc" id="L135">            doColumnMeta(propertyMeta);</span>
<span class="fc" id="L136">            entityMeta.ifPresent(em -&gt; doIdGenerator(propertyMeta, em));</span>

            // プロパティに対する型変換を設定します。
<span class="fc" id="L139">            ValueType&lt;?&gt; valueType = valueTypeRegistry.findValueType(propertyMeta);</span>

            // OracleなどBoolean型を純粋にサポートしていない場合は、int型に変換するタイプに変換する。
<span class="fc" id="L142">            valueType = dialect.getValueType(valueType);</span>
<span class="fc" id="L143">            propertyMeta.setValueType(valueType);</span>


<span class="fc" id="L146">            validateColumnProperty(declaringClass, propertyMeta);</span>

        }

<span class="fc" id="L150">        return propertyMeta;</span>

    }

    /**
     * プロパティのメタ情報に対する処理を実行します。
     * @param propertyMeta プロパティのメタ情報
     * @param field フィールド情報
     */
    private void doField(final PropertyMeta propertyMeta, final Field field) {

<span class="fc" id="L161">        propertyMeta.setField(field);</span>

<span class="fc" id="L163">        final Annotation[] annos = field.getAnnotations();</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">        for(Annotation anno : annos) {</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">            if(!isSupportedAnnotation(anno)) {</span>
<span class="nc" id="L166">                continue;</span>
            }

<span class="fc" id="L169">            final Class&lt;? extends Annotation&gt; annoClass = anno.annotationType();</span>
<span class="fc" id="L170">            propertyMeta.addAnnotation(annoClass, anno);</span>
        }
<span class="fc" id="L172">    }</span>

    /**
     * サポートするアノテーションか判定する。
     * &lt;p&gt;確実に重複するJava標準のアノテーションは除外するようにします。&lt;/p&gt;
     *
     * @param anno 判定対象のアノテーション
     * @return tureのときサポートします。
     */
    private boolean isSupportedAnnotation(final Annotation anno) {

<span class="fc" id="L183">        final String name = anno.annotationType().getName();</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if(name.startsWith(&quot;java.lang.annotation.&quot;)) {</span>
<span class="nc" id="L185">            return false;</span>
        }

<span class="fc" id="L188">        return true;</span>
    }

    /**
     * setterメソッドの情報を処理する。
     * @param propertyMeta プロパティのメタ情報
     * @param method setterメソッド
     */
    private void doSetterMethod(final PropertyMeta propertyMeta, final Method method) {

<span class="fc" id="L198">        final String methodName = method.getName();</span>
<span class="fc" id="L199">        final String propertyName = NameUtils.uncapitalize(methodName.substring(3));</span>

<span class="fc bfc" id="L201" title="All 2 branches covered.">        if(!propertyMeta.getName().equals(propertyName)) {</span>
            // プロパティ名が一致しない場合はスキップする
<span class="fc" id="L203">            return;</span>
        }

<span class="fc" id="L206">        propertyMeta.setWriteMethod(method);</span>

<span class="fc" id="L208">    }</span>

    /**
     * getterメソッドの情報を処理する。
     * @param propertyMeta プロパティのメタ情報
     * @param method getterメソッド
     */
    private void doGetterMethod(final PropertyMeta propertyMeta, final Method method) {

<span class="fc" id="L217">        final String methodName = method.getName();</span>
        final String propertyName;
<span class="fc bfc" id="L219" title="All 2 branches covered.">        if(methodName.startsWith(&quot;get&quot;)) {</span>
<span class="fc" id="L220">            propertyName = NameUtils.uncapitalize(methodName.substring(3));</span>
        } else {
            // 「is」から始まる場合
<span class="fc" id="L223">            propertyName = NameUtils.uncapitalize(methodName.substring(2));</span>
        }

<span class="fc bfc" id="L226" title="All 2 branches covered.">        if(!propertyMeta.getName().equals(propertyName)) {</span>
            // プロパティ名が一致しない場合はスキップする
<span class="fc" id="L228">            return;</span>
        }

<span class="fc" id="L231">        propertyMeta.setReadMethod(method);</span>

<span class="fc" id="L233">    }</span>

    /**
     * カラム情報を処理する。
     * @param propertyMeta プロパティのメタ情報
     */
    private void doColumnMeta(final PropertyMeta propertyMeta) {

<span class="fc" id="L241">        final ColumnMeta columnMeta = new ColumnMeta();</span>

<span class="fc" id="L243">        final String defaultColumnName = namingRule.propertyToColumn(propertyMeta.getName());</span>

<span class="fc" id="L245">        Optional&lt;Column&gt; annoColumn = propertyMeta.getAnnotation(Column.class);</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">        if(annoColumn.isPresent()) {</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">            if(!annoColumn.get().name().isEmpty()) {</span>
<span class="fc" id="L248">                columnMeta.setName(annoColumn.get().name());</span>
            } else {
<span class="nc" id="L250">                columnMeta.setName(defaultColumnName);</span>
            }

<span class="fc" id="L253">            columnMeta.setUpdatable(annoColumn.get().updatable());</span>

        } else {
<span class="fc" id="L256">            columnMeta.setName(defaultColumnName);</span>
        }

<span class="fc" id="L259">        propertyMeta.setColumnMeta(columnMeta);</span>

<span class="fc" id="L261">    }</span>

    /**
     * 主キーの生成情報を処理します。
     * @param propertyMeta プロパティのメタ情報
     * @param entityMeta エンティティのメタ情報
     */
    private void doIdGenerator(final PropertyMeta propertyMeta, final EntityMeta entityMeta) {

<span class="fc bfc" id="L270" title="All 2 branches covered.">        if(!propertyMeta.isId()) {</span>
<span class="fc" id="L271">            return;</span>
        }

<span class="fc" id="L274">        Optional&lt;GeneratedValue&gt; annoGeneratedValue = propertyMeta.getAnnotation(GeneratedValue.class);</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">        if(annoGeneratedValue.isEmpty()) {</span>
<span class="fc" id="L276">            return;</span>
        }

<span class="fc" id="L279">        final Class&lt;?&gt; propertyType = propertyMeta.getPropertyType();</span>

<span class="fc" id="L281">        GenerationType generationType = annoGeneratedValue.get().strategy();</span>
<span class="pc bpc" id="L282" title="2 of 4 branches missed.">        if(generationType != GenerationType.AUTO &amp;&amp; !dialect.supportsGenerationType(generationType)) {</span>
<span class="nc" id="L283">            throw new InvalidEntityException(entityMeta.getEntityType(), messageFormatter.create(&quot;property.anno.attr.notSupportForDialect&quot;)</span>
<span class="nc" id="L284">                    .paramWithClass(&quot;classType&quot;, entityMeta.getEntityType())</span>
<span class="nc" id="L285">                    .param(&quot;property&quot;, propertyMeta.getName())</span>
<span class="nc" id="L286">                    .paramWithAnno(&quot;anno&quot;, GeneratedValue.class)</span>
<span class="nc" id="L287">                    .param(&quot;attrName&quot;, &quot;strategy&quot;)</span>
<span class="nc" id="L288">                    .param(&quot;attrValue&quot;, generationType)</span>
<span class="nc" id="L289">                    .param(&quot;dialectName&quot;, dialect.getName())</span>
<span class="nc" id="L290">                    .format());</span>
        }

        // 生成戦略の補完
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">        if(generationType == GenerationType.AUTO) {</span>
<span class="nc" id="L295">            generationType = dialect.getDefaultGenerationType();</span>
        }

        final IdGenerator idGenerator;
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        if(StringUtils.hasLength(annoGeneratedValue.get().generator())) {</span>
            /*
             * 属性「generator」が指定されている場合は、「strategy」の値は無視する。
             * ただし、IDENTITYの場合はクエリ実行前に処理されてしまうので、
             * Autoに補完して間違った処理をされないようにする。
             */
<span class="nc" id="L305">            generationType = GenerationType.AUTO;</span>

<span class="nc" id="L307">            final String generatorName = annoGeneratedValue.get().generator();</span>
            try {
<span class="nc" id="L309">                idGenerator = applicationContext.getBean(generatorName, IdGenerator.class);</span>

<span class="nc" id="L311">            } catch(NoSuchBeanDefinitionException  e) {</span>
<span class="nc" id="L312">                throw new InvalidEntityException(entityMeta.getEntityType(), messageFormatter.create(&quot;property.anno.attr.noSuchBeanDefinition&quot;)</span>
<span class="nc" id="L313">                        .paramWithClass(&quot;classType&quot;, entityMeta.getEntityType())</span>
<span class="nc" id="L314">                        .param(&quot;property&quot;, propertyMeta.getName())</span>
<span class="nc" id="L315">                        .paramWithAnno(&quot;anno&quot;, GeneratedValue.class)</span>
<span class="nc" id="L316">                        .param(&quot;attrName&quot;, &quot;generator&quot;)</span>
<span class="nc" id="L317">                        .param(&quot;attrValue&quot;, generatorName)</span>
<span class="nc" id="L318">                        .format(), e);</span>
<span class="nc" id="L319">            } catch(BeanNotOfRequiredTypeException e) {</span>
<span class="nc" id="L320">                throw new InvalidEntityException(entityMeta.getEntityType(), messageFormatter.create(&quot;property.anno.attr.beanNotOfRequiredType&quot;)</span>
<span class="nc" id="L321">                        .paramWithClass(&quot;classType&quot;, entityMeta.getEntityType())</span>
<span class="nc" id="L322">                        .param(&quot;property&quot;, propertyMeta.getName())</span>
<span class="nc" id="L323">                        .paramWithAnno(&quot;anno&quot;, GeneratedValue.class)</span>
<span class="nc" id="L324">                        .param(&quot;attrName&quot;, &quot;generator&quot;)</span>
<span class="nc" id="L325">                        .param(&quot;attrValue&quot;, generatorName)</span>
<span class="nc" id="L326">                        .paramWithClass(&quot;requiredType&quot;, IdGenerator.class)</span>
<span class="nc" id="L327">                        .format(), e);</span>
<span class="nc" id="L328">            }</span>
<span class="pc bfc" id="L329" title="All 2 branches covered.">        } else if(generationType == GenerationType.IDENTITY) {</span>
<span class="fc" id="L330">            IdentityIdGenerator identityIdGenerator = new IdentityIdGenerator(propertyType);</span>
<span class="fc" id="L331">            idGenerator = identityIdGenerator;</span>

<span class="fc bfc" id="L333" title="All 2 branches covered.">        } else if(generationType == GenerationType.SEQUENCE) {</span>
<span class="fc" id="L334">            Optional&lt;SequenceGenerator&gt; annoSequenceGenerator = propertyMeta.getAnnotation(SequenceGenerator.class);</span>
            final String sequenceName;
<span class="pc bpc" id="L336" title="1 of 4 branches missed.">            if(annoSequenceGenerator.isPresent() &amp;&amp; !annoSequenceGenerator.get().sequenceName().isEmpty()) {</span>
<span class="fc" id="L337">                sequenceName = NameUtils.tableFullName(annoSequenceGenerator.get().sequenceName(),</span>
<span class="fc" id="L338">                        annoSequenceGenerator.get().catalog(),</span>
<span class="fc" id="L339">                        annoSequenceGenerator.get().schema());</span>
            } else {
<span class="fc" id="L341">                sequenceName = namingRule.sequenceNameForSequenceGenerator(entityMeta.getTableMeta().getName(), propertyMeta.getColumnMeta().getName());</span>
            }
<span class="fc" id="L343">            SequenceIdGenerator sequenceIdGenerator = new SequenceIdGenerator(</span>
<span class="fc" id="L344">                    dialect.getSequenceIncrementer(dataSource, sequenceName), propertyType);</span>

<span class="fc bfc" id="L346" title="All 2 branches covered.">            annoSequenceGenerator.map(a -&gt; a.format()).filter(f -&gt; !f.isEmpty()).ifPresent(f -&gt; {</span>
                try {
<span class="fc" id="L348">                    sequenceIdGenerator.setFormatter(new DecimalFormat(f));</span>
<span class="nc" id="L349">                } catch(IllegalArgumentException e) {</span>
<span class="nc" id="L350">                    throw new InvalidEntityException(entityMeta.getEntityType(), messageFormatter.create(&quot;property.anno.attr.wrongFormat&quot;)</span>
<span class="nc" id="L351">                            .paramWithClass(&quot;classType&quot;, entityMeta.getEntityType())</span>
<span class="nc" id="L352">                            .param(&quot;property&quot;, propertyMeta.getName())</span>
<span class="nc" id="L353">                            .paramWithAnno(&quot;anno&quot;, TableGenerator.class)</span>
<span class="nc" id="L354">                            .param(&quot;attrName&quot;, &quot;format&quot;)</span>
<span class="nc" id="L355">                            .param(&quot;attrValue&quot;, f)</span>
<span class="nc" id="L356">                            .format(), e);</span>
<span class="fc" id="L357">                }</span>
<span class="fc" id="L358">            });</span>

<span class="fc" id="L360">            idGenerator = sequenceIdGenerator;</span>

<span class="fc bfc" id="L362" title="All 2 branches covered.">        } else if(generationType == GenerationType.TABLE) {</span>
<span class="fc" id="L363">            Optional&lt;TableGenerator&gt; annoTableGenerator = propertyMeta.getAnnotation(TableGenerator.class);</span>

<span class="fc" id="L365">            final TableIdContext tableIdContext = new TableIdContext();</span>
<span class="fc" id="L366">            tableIdContext.setTable(tableIdGeneratorProperties.getTable());</span>
<span class="fc" id="L367">            tableIdContext.setSchema(tableIdGeneratorProperties.getSchema());</span>
<span class="fc" id="L368">            tableIdContext.setCatalog(tableIdGeneratorProperties.getCatalog());</span>
<span class="fc" id="L369">            tableIdContext.setPkColumn(tableIdGeneratorProperties.getPkColumn());</span>
<span class="fc" id="L370">            tableIdContext.setValueColumn(tableIdGeneratorProperties.getValueColumn());</span>
<span class="fc" id="L371">            tableIdContext.setAllocationSize(tableIdGeneratorProperties.getAllocationSize());</span>
<span class="fc" id="L372">            tableIdContext.setInitialValue(tableIdGeneratorProperties.getInitialValue());</span>

<span class="fc" id="L374">            annoTableGenerator.ifPresent(a -&gt; {</span>
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">                if(!a.table().isEmpty()) {</span>
<span class="nc" id="L376">                    tableIdContext.setTable(a.table());</span>
                }

<span class="pc bpc" id="L379" title="1 of 2 branches missed.">                if(!a.schema().isEmpty()) {</span>
<span class="nc" id="L380">                    tableIdContext.setSchema(a.schema());</span>
                }

<span class="pc bpc" id="L383" title="1 of 2 branches missed.">                if(!a.catalog().isEmpty()) {</span>
<span class="nc" id="L384">                    tableIdContext.setCatalog(a.catalog());</span>
                }

<span class="pc bpc" id="L387" title="1 of 2 branches missed.">                if(!a.pkColumn().isEmpty()) {</span>
<span class="nc" id="L388">                    tableIdContext.setPkColumn(a.pkColumn());</span>
                }

<span class="pc bpc" id="L391" title="1 of 2 branches missed.">                if(!a.valueColumn().isEmpty()) {</span>
<span class="nc" id="L392">                    tableIdContext.setValueColumn(a.valueColumn());</span>
                }

<span class="pc bpc" id="L395" title="1 of 2 branches missed.">                if(a.initialValue() &gt;= 0L) {</span>
<span class="nc" id="L396">                    tableIdContext.setInitialValue(a.initialValue());</span>
                }

<span class="pc bpc" id="L399" title="1 of 2 branches missed.">                if(a.allocationSize() &gt;= 1L) {</span>
<span class="nc" id="L400">                    tableIdContext.setAllocationSize(a.allocationSize());</span>
                }

<span class="fc" id="L403">            });</span>


            final String sequenceName;
<span class="pc bpc" id="L407" title="1 of 4 branches missed.">            if(annoTableGenerator.isPresent() &amp;&amp; !annoTableGenerator.get().sequenceName().isEmpty()) {</span>
<span class="nc" id="L408">                sequenceName = annoTableGenerator.get().sequenceName();</span>
            } else {
<span class="fc" id="L410">                sequenceName = namingRule.sequenceNameForTableGenerator(entityMeta.getTableMeta().getName(), propertyMeta.getColumnMeta().getName());</span>
            }

<span class="fc" id="L413">            TableIdGenerator tableIdGenerator = new TableIdGenerator(</span>
<span class="fc" id="L414">                    new TableIdIncrementer(getJdbcTemplate(), tableIdContext),</span>
<span class="fc" id="L415">                    propertyMeta.getPropertyType(), sequenceName);</span>


<span class="pc bpc" id="L418" title="1 of 2 branches missed.">            annoTableGenerator.map(a -&gt; a.format()).filter(f -&gt; !f.isEmpty()).ifPresent(f -&gt; {</span>
                try {
<span class="fc" id="L420">                    tableIdGenerator.setFormatter(new DecimalFormat(f));</span>
<span class="nc" id="L421">                } catch(IllegalArgumentException e) {</span>
<span class="nc" id="L422">                    throw new InvalidEntityException(entityMeta.getEntityType(), messageFormatter.create(&quot;property.anno.attr.wrongFormat&quot;)</span>
<span class="nc" id="L423">                            .paramWithClass(&quot;classType&quot;, entityMeta.getEntityType())</span>
<span class="nc" id="L424">                            .param(&quot;property&quot;, propertyMeta.getName())</span>
<span class="nc" id="L425">                            .paramWithAnno(&quot;anno&quot;, TableGenerator.class)</span>
<span class="nc" id="L426">                            .param(&quot;attrName&quot;, &quot;format&quot;)</span>
<span class="nc" id="L427">                            .param(&quot;attrValue&quot;, f)</span>
<span class="nc" id="L428">                            .format(), e);</span>
<span class="fc" id="L429">                }</span>
<span class="fc" id="L430">            });</span>

<span class="fc" id="L432">            idGenerator = tableIdGenerator;</span>


<span class="pc bpc" id="L435" title="1 of 2 branches missed.">        } else if(generationType == GenerationType.UUID) {</span>
<span class="fc" id="L436">            idGenerator = new UUIDGenerator(propertyType);</span>

        } else {
<span class="nc" id="L439">            throw new InvalidEntityException(entityMeta.getEntityType(), messageFormatter.create(&quot;property.anno.attr.notSupportValue&quot;)</span>
<span class="nc" id="L440">                    .paramWithClass(&quot;classType&quot;, entityMeta.getClass())</span>
<span class="nc" id="L441">                    .param(&quot;property&quot;, propertyMeta.getName())</span>
<span class="nc" id="L442">                    .paramWithAnno(&quot;anno&quot;, GeneratedValue.class)</span>
<span class="nc" id="L443">                    .param(&quot;attrName&quot;, &quot;strategy&quot;)</span>
<span class="nc" id="L444">                    .paramWithEnum(&quot;attrValue&quot;, generationType)</span>
<span class="nc" id="L445">                    .format());</span>
        }

<span class="pc bpc" id="L448" title="1 of 2 branches missed.">        if(!idGenerator.isSupportedType(propertyType)) {</span>
<span class="nc" id="L449">            throw new InvalidEntityException(entityMeta.getClass(), messageFormatter.create(&quot;property.anno.notSupportTypeList&quot;)</span>
<span class="nc" id="L450">                    .paramWithClass(&quot;classType&quot;, entityMeta.getEntityType())</span>
<span class="nc" id="L451">                    .param(&quot;property&quot;, propertyMeta.getName())</span>
<span class="nc" id="L452">                    .paramWithAnno(&quot;anno&quot;, GeneratedValue.class)</span>
<span class="nc" id="L453">                    .paramWithClass(&quot;actualType&quot;, propertyType)</span>
<span class="nc" id="L454">                    .paramWithClass(&quot;expectedTypeList&quot;, idGenerator.getSupportedTypes())</span>
<span class="nc" id="L455">                    .format());</span>
        }

<span class="fc" id="L458">        propertyMeta.setIdGenerator(idGenerator);</span>
<span class="fc" id="L459">        propertyMeta.setIdGeneratonType(generationType);</span>

        // 生成対象のIDの情報
<span class="fc" id="L462">        final IdGenerationContext generationContext = new IdGenerationContext();</span>
<span class="fc" id="L463">        generationContext.setTableMeta(entityMeta.getTableMeta());</span>
<span class="fc" id="L464">        generationContext.setColumnMeta(propertyMeta.getColumnMeta());</span>
<span class="fc" id="L465">        generationContext.setEntityType(entityMeta.getEntityType());</span>
<span class="fc" id="L466">        generationContext.setPropertyType(propertyMeta.getPropertyType());</span>
<span class="fc" id="L467">        propertyMeta.setIdGenerationContext(generationContext);</span>

<span class="fc" id="L469">    }</span>

    /**
     * カラムとなるプロパティの整合性のチェック。
     * アノテーションとクラスタイプのチェック
     *
     * @param declaringClass プロパティが定義されているクラス
     * @param propertyMeta チェック対象のプロパティ
     */
    private void validateColumnProperty(final Class&lt;?&gt; declaringClass, final PropertyMeta propertyMeta) {

<span class="fc" id="L480">        final Class&lt;?&gt; propertyType = propertyMeta.getPropertyType();</span>

        // 主キーのタイプチェック
<span class="pc bpc" id="L483" title="1 of 14 branches missed.">        if(propertyMeta.isId()</span>
                &amp;&amp; propertyType != String.class
                &amp;&amp; propertyType != UUID.class
                &amp;&amp; propertyType != Integer.class &amp;&amp; propertyType != int.class
                &amp;&amp; propertyType != Long.class &amp;&amp; propertyType != long.class) {

<span class="nc" id="L489">            throw new InvalidEntityException(declaringClass, messageFormatter.create(&quot;property.anno.notSupportTypeList&quot;)</span>
<span class="nc" id="L490">                    .paramWithClass(&quot;classType&quot;, declaringClass)</span>
<span class="nc" id="L491">                    .param(&quot;property&quot;, propertyMeta.getName())</span>
<span class="nc" id="L492">                    .paramWithAnno(&quot;anno&quot;, Id.class)</span>
<span class="nc" id="L493">                    .paramWithClass(&quot;actualType&quot;, propertyType)</span>
<span class="nc" id="L494">                    .paramWithClass(&quot;expectedTypeList&quot;, String.class, Integer.class, int.class, Long.class, long.class)</span>
<span class="nc" id="L495">                    .format());</span>
        }

        // 主キーでないのに値の生成用のアノテーションが付与されている場合
<span class="pc bpc" id="L499" title="1 of 4 branches missed.">        if(!propertyMeta.isId() &amp;&amp; propertyMeta.hasAnnotation(GeneratedValue.class)) {</span>

<span class="nc" id="L501">            throw new InvalidEntityException(declaringClass, messageFormatter.create(&quot;property.anno.notIdWithGeneratedValue&quot;)</span>
<span class="nc" id="L502">                    .paramWithClass(&quot;classType&quot;, declaringClass)</span>
<span class="nc" id="L503">                    .param(&quot;property&quot;, propertyMeta.getName())</span>
<span class="nc" id="L504">                    .paramWithAnno(&quot;anno&quot;, GeneratedValue.class)</span>
<span class="nc" id="L505">                    .format());</span>
        }


        // 列挙型のタイプチェック
<span class="pc bpc" id="L510" title="1 of 4 branches missed.">        if(propertyMeta.hasAnnotation(Enumerated.class) &amp;&amp; !propertyType.isEnum()) {</span>

<span class="nc" id="L512">            throw new InvalidEntityException(declaringClass, messageFormatter.create(&quot;property.anno.notSupportType&quot;)</span>
<span class="nc" id="L513">                    .paramWithClass(&quot;classType&quot;, declaringClass)</span>
<span class="nc" id="L514">                    .param(&quot;property&quot;, propertyMeta.getName())</span>
<span class="nc" id="L515">                    .paramWithAnno(&quot;anno&quot;, Enumerated.class)</span>
<span class="nc" id="L516">                    .paramWithClass(&quot;actualType&quot;, propertyType)</span>
<span class="nc" id="L517">                    .paramWithClass(&quot;expectedType&quot;, Enum.class)</span>
<span class="nc" id="L518">                    .format());</span>
        }

        // バージョンキーのタイプチェック
<span class="pc bpc" id="L522" title="3 of 10 branches missed.">        if(propertyMeta.hasAnnotation(Version.class)</span>
                &amp;&amp; propertyType != Integer.class &amp;&amp; propertyType != int.class
                &amp;&amp; propertyType != Long.class &amp;&amp; propertyType != long.class) {

<span class="nc" id="L526">            throw new InvalidEntityException(declaringClass, messageFormatter.create(&quot;property.anno.notSupportTypeList&quot;)</span>
<span class="nc" id="L527">                    .paramWithClass(&quot;classType&quot;, declaringClass)</span>
<span class="nc" id="L528">                    .param(&quot;property&quot;, propertyMeta.getName())</span>
<span class="nc" id="L529">                    .paramWithAnno(&quot;anno&quot;, Version.class)</span>
<span class="nc" id="L530">                    .paramWithClass(&quot;actualType&quot;, propertyType)</span>
<span class="nc" id="L531">                    .paramWithClass(&quot;expectedTypeList&quot;, Integer.class, int.class, Long.class, long.class)</span>
<span class="nc" id="L532">                    .format());</span>

        }

        // 時制のタイプチェック
<span class="pc bpc" id="L537" title="1 of 4 branches missed.">        if(!propertyMeta.hasAnnotation(Temporal.class)</span>
                &amp;&amp; propertyType == java.util.Date.class) {

            // 時制の型が不明なプロパティに対して、@Temporalが付与されていない場合
<span class="nc" id="L541">            throw new InvalidEntityException(declaringClass, messageFormatter.create(&quot;property.anno.requiredAnnoTemporal&quot;)</span>
<span class="nc" id="L542">                    .paramWithClass(&quot;classType&quot;, declaringClass)</span>
<span class="nc" id="L543">                    .param(&quot;property&quot;, propertyMeta.getName())</span>
<span class="nc" id="L544">                    .paramWithAnno(&quot;anno&quot;, Temporal.class)</span>
<span class="nc" id="L545">                    .format());</span>
        }

<span class="fc" id="L548">    }</span>

    /**
     * {@link TableIdGenerator}用の {@link JdbcTemplate} を取得します。
     * @return {@link JdbcTemplate}のインスタンス。
     */
    private JdbcTemplate getJdbcTemplate() {
<span class="fc" id="L555">        return JdbcTemplateBuilder.create(dataSource, jdbcTemplateProperties)</span>
<span class="fc" id="L556">                .build();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>