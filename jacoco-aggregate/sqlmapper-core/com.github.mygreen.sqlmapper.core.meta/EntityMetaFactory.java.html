<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>EntityMetaFactory.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">SqlMapper</a> &gt; <a href="../index.html" class="el_bundle">sqlmapper-core</a> &gt; <a href="index.source.html" class="el_package">com.github.mygreen.sqlmapper.core.meta</a> &gt; <span class="el_source">EntityMetaFactory.java</span></div><h1>EntityMetaFactory.java</h1><pre class="source lang-java linenums">package com.github.mygreen.sqlmapper.core.meta;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.util.ReflectionUtils;

import com.github.mygreen.messageformatter.MessageFormatter;
import com.github.mygreen.sqlmapper.core.annotation.Embeddable;
import com.github.mygreen.sqlmapper.core.annotation.EmbeddedId;
import com.github.mygreen.sqlmapper.core.annotation.Entity;
import com.github.mygreen.sqlmapper.core.annotation.MappedSuperclass;
import com.github.mygreen.sqlmapper.core.annotation.Table;
import com.github.mygreen.sqlmapper.core.annotation.Version;
import com.github.mygreen.sqlmapper.core.naming.NamingRule;

import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;

/**
 * エンティティのメタ情報を作成します。
 *
 *
 * @author T.TSUCHIE
 *
 */
<span class="fc" id="L35">public class EntityMetaFactory {</span>

    /**
     * 命名規則の定義です。
     * Springのインジェクション対象です。
     */
    @Getter
    @Setter
    @Autowired
    private NamingRule namingRule;

    /**
     * メッセージフォーマッタです。
     * Springのインジェクション対象です。
     */
    @Getter
    @Setter
    @Autowired
    private MessageFormatter messageFormatter;

    /**
     * プロパティのメタ情報を作成します。
     * Springのインジェクション対象です。
     */
    @Getter
    @Setter
    @Autowired
    private PropertyMetaFactory propertyMetaFactory;

    /**
     * エンティティのメタ情報のキャッシュ用マップです。
     * &lt;p&gt;key=エンティティのFQN, value=EntityMeta&lt;/p&gt;
     */
<span class="fc" id="L68">    private ConcurrentHashMap&lt;String, EntityMeta&gt; entityMetaMap = new ConcurrentHashMap&lt;&gt;(200);</span>

    /**
     * 作成したエンティティのメタ情報をクリアします。
     */
    public void clear() {
<span class="nc" id="L74">        this.entityMetaMap.clear();</span>
<span class="nc" id="L75">    }</span>

    /**
     * エンティティ情報を元にメタ情報を組み立てます。
     * 組み立ててたメタ情報はキャッシュしており、組み立て済みの場合はキャッシュを返します。
     *
     * @param entityClass エンティティクラス
     * @return エンティティのメタ情報
     */
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">    public EntityMeta create(@NonNull final Class&lt;?&gt; entityClass) {</span>
<span class="fc" id="L85">        return entityMetaMap.computeIfAbsent(entityClass.getName(), s -&gt; doEntityMeta(entityClass));</span>
    }

    /**
     * エンティティのメタ情報に対応する処理を実行します。
     * @param entityClass エンティティ情報
     * @return エンティティのメタ情報
     */
    private EntityMeta doEntityMeta(final Class&lt;?&gt; entityClass) {

<span class="fc" id="L95">        final Entity annoEntity = entityClass.getAnnotation(Entity.class);</span>
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">        if(annoEntity == null) {</span>
<span class="nc" id="L97">            throw new InvalidEntityException(entityClass, messageFormatter.create(&quot;entity.anno.required&quot;)</span>
<span class="nc" id="L98">                    .paramWithClass(&quot;entityClass&quot;, entityClass)</span>
<span class="nc" id="L99">                    .paramWithAnno(&quot;anno&quot;, Entity.class)</span>
<span class="nc" id="L100">                    .format());</span>
        }

<span class="fc" id="L103">        final EntityMeta entityMeta = new EntityMeta(entityClass);</span>

<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        if(!annoEntity.name().isEmpty()) {</span>
<span class="nc" id="L106">            entityMeta.setName(annoEntity.name());</span>
        } else {
<span class="fc" id="L108">            entityMeta.setName(entityClass.getSimpleName());</span>
        }

<span class="fc" id="L111">        doTableMeta(entityMeta, entityClass);</span>
<span class="fc" id="L112">        doPropertyMeta(entityMeta, entityClass);</span>

<span class="fc" id="L114">        return entityMeta;</span>
    }

    /**
     * エンティティ情報からテーブルのメタ情報に対応する処理を実行します。
     * @param entityMeta エンティティメタ情報
     * @param entityClass エンティティ情報
     */
    private void doTableMeta(final EntityMeta entityMeta, final Class&lt;?&gt; entityClass) {

<span class="fc" id="L124">        final TableMeta tableMeta = new TableMeta();</span>
<span class="fc" id="L125">        final String defaultName = namingRule.entityToTable(entityClass.getName());</span>
<span class="fc" id="L126">        final Table annoTable = entityClass.getAnnotation(Table.class);</span>

<span class="pc bpc" id="L128" title="1 of 2 branches missed.">        if(annoTable != null) {</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">            if(!annoTable.name().isEmpty()) {</span>
<span class="nc" id="L130">                tableMeta.setName(annoTable.name());</span>
            } else {
<span class="nc" id="L132">                tableMeta.setName(defaultName);</span>
            }

<span class="nc bnc" id="L135" title="All 2 branches missed.">            if(!annoTable.schema().isEmpty()) {</span>
<span class="nc" id="L136">                tableMeta.setSchema(annoTable.schema());</span>
            }

<span class="nc bnc" id="L139" title="All 2 branches missed.">            if(!annoTable.catalog().isEmpty()) {</span>
<span class="nc" id="L140">                tableMeta.setCatalog(annoTable.catalog());</span>
            }

        } else {
<span class="fc" id="L144">            tableMeta.setName(defaultName);</span>
        }

<span class="fc" id="L147">        entityMeta.setTableMeta(tableMeta);</span>

<span class="fc" id="L149">    }</span>

    /**
     * エンティティ情報からプロパティのメタ情報に対応する処理を実行します。
     * @param entityMeta エンティティメタ情報
     * @param entityClass エンティティ情報
     */
    private void doPropertyMeta(final EntityMeta entityMeta, final Class&lt;?&gt; entityClass) {

<span class="fc" id="L158">        final List&lt;PropertyMeta&gt; propertyMetaList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L159">        extractProperty(entityClass, propertyMetaList, entityMeta);</span>
<span class="fc" id="L160">        extractSuperClassProperty(entityClass.getSuperclass(), propertyMetaList, entityMeta);</span>

        // 埋め込みのプロパティを抽出する
<span class="fc" id="L163">        propertyMetaList.stream()</span>
<span class="fc" id="L164">            .filter(prop -&gt; prop.isEmbedded())</span>
<span class="fc" id="L165">            .forEach(prop -&gt; doEmbeddedPropertyMeta(entityClass, prop, entityMeta));</span>

<span class="fc" id="L167">        validateEntity(entityClass, propertyMetaList);</span>

<span class="fc" id="L169">        propertyMetaList.stream().forEach(p -&gt; entityMeta.addPropertyMeta(p));</span>

<span class="fc" id="L171">    }</span>

    /**
     * 指定したクラスからプロパティを抽出する。
     * @param targetClass 抽出対象のクラス。
     * @param propertyMetaList 抽出したプロパティ一覧
     * @param entityMeta エンティティのメタ情報
     */
    private void extractProperty(final Class&lt;?&gt; targetClass, final List&lt;PropertyMeta&gt; propertyMetaList,
            final EntityMeta entityMeta) {

<span class="fc bfc" id="L182" title="All 2 branches covered.">        for(Field field : targetClass.getDeclaredFields()) {</span>

<span class="fc" id="L184">            int modifiers = field.getModifiers();</span>
<span class="pc bpc" id="L185" title="2 of 4 branches missed.">            if(Modifier.isStatic(modifiers) || Modifier.isFinal(modifiers)) {</span>
<span class="nc" id="L186">                continue;</span>
            }

<span class="fc" id="L189">            ReflectionUtils.makeAccessible(field);</span>

<span class="fc" id="L191">            propertyMetaList.add(propertyMetaFactory.create(field, entityMeta));</span>

        }
<span class="fc" id="L194">    }</span>

    /**
     * アノテーション{@literal MappedSuperclass}が付与されている親クラスのプロパティを抽出する。
     * &lt;p&gt;親クラスにフィールドやアノテーションが定義してある可能性があるので、それらも取得する。&lt;/p&gt;
     * @param superClass 親クラス
     * @param propertyMetaList 抽出したプロパティ一覧
     * @param entityClass エンティティ情報
     */
    private void extractSuperClassProperty(final Class&lt;?&gt; superClass, final List&lt;PropertyMeta&gt; propertyMetaList,
            final EntityMeta entityMeta) {

<span class="fc bfc" id="L206" title="All 2 branches covered.">        if(superClass.equals(Object.class)) {</span>
<span class="fc" id="L207">            return;</span>
        }

<span class="fc" id="L210">        final MappedSuperclass annoMappedSuperclass = superClass.getAnnotation(MappedSuperclass.class);</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">        if(annoMappedSuperclass != null) {</span>
<span class="fc" id="L212">            extractProperty(superClass, propertyMetaList, entityMeta);</span>
        }

        // 再帰的に遡っていく
<span class="fc" id="L216">        extractSuperClassProperty(superClass.getSuperclass(), propertyMetaList, entityMeta);</span>

<span class="fc" id="L218">    }</span>

    /**
     * 指定したプロパティから埋め込み用プロパティを設定する。
     * @param targetClass 抽出対象のクラス。
     * @param propertyMeta 処理対象のプロパティ情報
     * @param entityClass エンティティ情報
     */
    private void doEmbeddedPropertyMeta(final Class&lt;?&gt; entityClass, final PropertyMeta propertyMeta,
            final EntityMeta entityMeta) {

<span class="fc" id="L229">        final Class&lt;?&gt; embeddableClass = propertyMeta.getPropertyType();</span>

<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        if(embeddableClass.getAnnotation(Embeddable.class) == null) {</span>
<span class="nc" id="L232">            throw new InvalidEntityException(entityClass, messageFormatter.create(&quot;embeddable.anno.required&quot;)</span>
<span class="nc" id="L233">                    .paramWithClass(&quot;entityClass&quot;, entityClass)</span>
<span class="nc" id="L234">                    .param(&quot;property&quot;, propertyMeta.getName())</span>
<span class="nc" id="L235">                    .paramWithClass(&quot;embeddableClass&quot;, embeddableClass)</span>
<span class="nc" id="L236">                    .paramWithAnno(&quot;anno&quot;, Embeddable.class)</span>
<span class="nc" id="L237">                    .format());</span>
        }

        // 埋め込みクラスのプロパティ情報の抽出
<span class="fc" id="L241">        final List&lt;PropertyMeta&gt; embeddedPropertyList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L242">        extractProperty(embeddableClass, embeddedPropertyList, entityMeta);</span>

<span class="fc" id="L244">        validatedEmbeddedProperty(entityClass, embeddableClass, embeddedPropertyList);</span>

<span class="fc" id="L246">        embeddedPropertyList.stream().forEach(p -&gt; propertyMeta.addEmbeddedablePropertyMeta(p));</span>

<span class="fc" id="L248">    }</span>

    /**
     * 埋め込みクラスの情報の整合性などの検証
     * &lt;p&gt;
     *  &lt;li&gt;&lt;/li&gt;
     * &lt;/p&gt;
     *
     * @param entityClass
     * @param embeddableClass
     * @param embeddedProperties
     */
    private void validatedEmbeddedProperty(final Class&lt;?&gt; entityClass, final Class&lt;?&gt; embeddableClass,
            final List&lt;PropertyMeta&gt; embeddedPropertyList) {

        // プロパティが存在するかどうか。
<span class="fc" id="L264">        final long propertyCount = embeddedPropertyList.stream()</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">                .filter(p -&gt; !p.isTransient())</span>
<span class="fc" id="L266">                .count();</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">        if(propertyCount == 0) {</span>
<span class="nc" id="L268">            throw new InvalidEntityException(entityClass, messageFormatter.create(&quot;entity.prop.empty&quot;)</span>
<span class="nc" id="L269">                    .paramWithClass(&quot;classType&quot;, embeddableClass)</span>
<span class="nc" id="L270">                    .format());</span>
        }

<span class="fc" id="L273">    }</span>

    private void validateEntity(final Class&lt;?&gt; entityClass, final List&lt;PropertyMeta&gt; propertyMetaList) {

        // プロパティが存在するかどうか。
<span class="fc" id="L278">        final long propertyCount = propertyMetaList.stream()</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">                .filter(p -&gt; !p.isTransient())</span>
<span class="fc" id="L280">                .count();</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">        if(propertyCount == 0) {</span>
<span class="nc" id="L282">            throw new InvalidEntityException(entityClass, messageFormatter.create(&quot;entity.prop.empty&quot;)</span>
<span class="nc" id="L283">                    .paramWithClass(&quot;classType&quot;, entityClass)</span>
<span class="nc" id="L284">                    .format());</span>
        }

        // カラム用のプロパティが重複していないかどうか
<span class="fc" id="L288">        Set&lt;String&gt; existsColumnPropertyNames = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L289">        Set&lt;String&gt; douplicatedColumnPropertyNames = new TreeSet&lt;&gt;();</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">        for(PropertyMeta prop : propertyMetaList) {</span>
<span class="fc bfc" id="L291" title="All 4 branches covered.">            if(prop.isTransient() || !prop.isColumn()) {</span>
<span class="fc" id="L292">                continue;</span>
            }

<span class="fc" id="L295">            final String propName = prop.getName();</span>
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">            if(!existsColumnPropertyNames.add(propName)) {</span>
<span class="nc" id="L297">                douplicatedColumnPropertyNames.add(propName);</span>
            }

            // 埋め込みプロパティの場合
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">            for(PropertyMeta embeddedProp : prop.getEmbeddedablePopertyMetaList()) {</span>
<span class="nc bnc" id="L302" title="All 4 branches missed.">                if(embeddedProp.isTransient() || !prop.isColumn()) {</span>
<span class="nc" id="L303">                    continue;</span>
                }
<span class="nc" id="L305">                final String embeddedPropName = embeddedProp.getName();</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">                if(!existsColumnPropertyNames.add(embeddedPropName)) {</span>
<span class="nc" id="L307">                    douplicatedColumnPropertyNames.add(embeddedPropName);</span>
                }
<span class="nc" id="L309">            }</span>

<span class="fc" id="L311">        }</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">        if(douplicatedColumnPropertyNames.size() &gt; 0) {</span>
<span class="nc" id="L313">            throw new InvalidEntityException(entityClass, messageFormatter.create(&quot;entity.prop.columnDuplicated&quot;)</span>
<span class="nc" id="L314">                    .paramWithClass(&quot;classType&quot;, entityClass)</span>
<span class="nc" id="L315">                    .param(&quot;propertyNames&quot;, douplicatedColumnPropertyNames)</span>
<span class="nc" id="L316">                    .format());</span>
        }

        // EmbeddedIdが複数存在しないかどうか。
<span class="fc" id="L320">        List&lt;PropertyMeta&gt; embeddedIdList = propertyMetaList.stream()</span>
<span class="fc" id="L321">                .filter(prop -&gt; prop.isId())</span>
<span class="fc" id="L322">                .filter(prop -&gt; prop.isEmbedded())</span>
<span class="fc" id="L323">                .collect(Collectors.toList());</span>
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">        if(embeddedIdList.size() &gt;= 2) {</span>
<span class="nc" id="L325">            List&lt;String&gt; propertyNames = embeddedIdList.stream()</span>
<span class="nc" id="L326">                    .map(prop -&gt; prop.getName())</span>
<span class="nc" id="L327">                    .collect(Collectors.toList());</span>

<span class="nc" id="L329">            throw new InvalidEntityException(entityClass, messageFormatter.create(&quot;entity.anno.multiPropertyAnno&quot;)</span>
<span class="nc" id="L330">                    .paramWithClass(&quot;classType&quot;, entityClass)</span>
<span class="nc" id="L331">                    .paramWithAnno(&quot;anno&quot;, EmbeddedId.class)</span>
<span class="nc" id="L332">                    .param(&quot;propertyNames&quot;, propertyNames)</span>
<span class="nc" id="L333">                    .format());</span>
        }

        // バージョンキーが複数存在しないかどうか。
<span class="fc" id="L337">        List&lt;PropertyMeta&gt; versionList = propertyMetaList.stream()</span>
<span class="fc" id="L338">                .filter(prop -&gt; prop.isVersion())</span>
<span class="fc" id="L339">                .collect(Collectors.toList());</span>
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">        if(versionList.size() &gt;= 2) {</span>
<span class="nc" id="L341">            List&lt;String&gt; propertyNames = versionList.stream()</span>
<span class="nc" id="L342">                    .map(prop -&gt; prop.getName())</span>
<span class="nc" id="L343">                    .collect(Collectors.toList());</span>

<span class="nc" id="L345">            throw new InvalidEntityException(entityClass, messageFormatter.create(&quot;entity.anno.multiPropertyAnno&quot;)</span>
<span class="nc" id="L346">                    .paramWithClass(&quot;classType&quot;, entityClass)</span>
<span class="nc" id="L347">                    .paramWithAnno(&quot;anno&quot;, Version.class)</span>
<span class="nc" id="L348">                    .param(&quot;propertyNames&quot;, propertyNames)</span>
<span class="nc" id="L349">                    .format());</span>
        }

        // バージョンキーを持つとき主キーが存在するかどうか
<span class="fc bfc" id="L353" title="All 2 branches covered.">        if(versionList.size() &gt; 0) {</span>
<span class="fc" id="L354">            boolean existsId = propertyMetaList.stream()</span>
<span class="fc" id="L355">                    .anyMatch(prop -&gt; prop.isId());</span>
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">            if(!existsId) {</span>
<span class="nc" id="L357">                throw new InvalidEntityException(entityClass, messageFormatter.create(&quot;entity.noIdWhenVersion&quot;)</span>
<span class="nc" id="L358">                        .paramWithClass(&quot;classType&quot;, entityClass)</span>
<span class="nc" id="L359">                        .format());</span>
            }
        }

<span class="fc" id="L363">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>